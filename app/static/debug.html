<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live View - Sunscan</title>
    <script src="js/chart.js"></script>
    <style>
        canvas {
            width: 100%;
            height: 100%;
            border: 1px solid #ccc; /* Ajout d'une bordure l√©g√®re */
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1); /* L√©g√®re ombre pour esth√©tique */
            background-color: #f9f9f9; /* Fond l√©ger */
        }
        .chart-container {
            width: 800px;
            height: 400px;
            margin-bottom: 30px; /* Espacement entre les graphiques */
        }
    </style>
    <style>
        #controls {
            margin-bottom: 20px;
        }
        .control-field {
            margin: 10px 0;
        }
        #response {
            margin-top: 20px;
            font-family: monospace;
            white-space: pre-wrap;
            background-color: #f0f0f0;
            padding: 10px;
            border: 1px solid #ccc;
        }
        #status {
            margin-top: 10px;
            font-weight: bold;
        }
        #normalize-buttons {
            margin-top: 20px;
        }
        .normalize-button {
            padding: 10px 20px;
            margin-right: 5px;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            cursor: pointer;
        }
        .normalize-button.active {
            background-color: #007bff;
            color: #fff;
            border: 1px solid #007bff;
        }
        .color-indicator {
            width: 100px;
            height: 50px;
            border: 1px solid #ccc;
        }
        .color-rgb {
            background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet);
        }
        .color-red {
            background-color: red;
        }
        .color-green {
            background-color: green;
        }
        .color-blue {
            background-color: blue;
        }
        .restart-button {
            background-color: #dc3545;
        }
        .snapshot-button {
            background-color: #28a745;
        }
        .record-button {
            background-color: #dc3545;
            color: white;
        }
        .stop-button {
            background-color: #007bff;
            color: white;
        }
        .icon-circle {
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        .icon-square {
            width: 16px;
            height: 16px;
            background-color: white;
            display: inline-block;
            margin-right: 10px;
        }
        .shutdown-button {
            background-color: #343a40;
        }

        #crop-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        #crop-controls button {
            width: 100px;
            height: 40px;
            margin: 5px 0;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            transition: background-color 0.2s;
        }

        #crop-controls button:hover {
            background-color: #e0e0e0;
        }

        #crop-controls button i {
            font-style: normal;
            font-size: 20px;
        }

        .crop-info {
            display: flex;
            flex-direction: column;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            min-width: 120px;
        }

        .crop-info span {
            margin: 2px 0;
        }

        .adu-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .adu-box {
            width: 150px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            border-radius: 5px;
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
        }

        .adu-box.red {
            background-color: red;
        }

        .adu-box.green {
            background-color: green;
        }

        .adu-box.blue {
            background-color: blue;
        }
    </style>
</head>
<body>
    <h1>Live View</h1>
    <div id="connection-info">
        Connexion au serveur : <span id="connection-hostname">...</span>
    </div>
    <div id="controls">
        <button id="connect-button">Connecter</button>
        <button id="disconnect-button">D√©connecter</button>
        <button id="update-status">Mettre √† jour le statut</button>
        <div id="status">Statut : <span id="camera-status">...</span></div>
        <div class="control-field">
            <label for="exposure">Exposition (0.1 √† 10000.0) :</label>
            <input type="number" id="exposure" min="0.1" max="10000.0" step="0.1" value="80">
        </div>
        <div class="control-field">
            <label for="gain">Gain (1.0 √† 10.0) :</label>
            <input type="number" id="gain" min="1.0" max="10.0" step="0.1" value="1.0">
        </div>
        <button id="apply-controls">Appliquer</button>
        <div id="normalize-buttons">
            <button class="normalize-button" data-normalization="0">Mode 0</button>
            <button class="normalize-button" data-normalization="1">Mode 1</button>
            <button class="normalize-button" data-normalization="2">Mode 2</button>
        </div>
        <div class="control-field">
            <button id="toggle-color-mode">Switch</button>
            <div id="color-indicator" class="color-indicator"></div>
        </div>
        <div class="control-field">
            <button id="take-snapshot" class="snapshot-button">
                <i class="camera-icon">üì∑</i> Prendre un Snapshot
            </button>    
        </div>
        <div class="control-field">
            <button id="start-record" class="record-button">
                <span class="icon-circle"></span>D√©marrer Enregistrement
            </button>
        </div>
        <div class="control-field">
            <button id="stop-record" class="stop-button">
                <span class="icon-square"></span>Arr√™ter Enregistrement
            </button>
        </div>
        <div class="control-field">
            <button id="recreate-websocket">Recr√©er WebSocket</button>
        </div>
        <div id="status">WebSocket : <span id="websocket-status">...</span></div>
        <div class="control-field">
            <button id="restart-rpi" class="restart-button">Red√©marrer</button>
            <button id="shutdown-rpi" class="shutdown-button">Shutdown</button>
            <button id="sunscan-infos">Sunscan Infos</button>
        </div>
    </div>
    <!-- Conteneur des boutons Crop -->
    <h2>Contr√¥le du Crop</h2>
    <div id="crop-controls">
        <div id="crop-info" class="crop-info">
            <span>Crop Y: ---</span>
            <span>Crop Height: ---</span>
        </div>
        <button id="crop-up"><i>&#x2191;</i></button> <!-- Fl√®che vers le haut -->
        <button id="toggle-crop">Crop</button> <!-- Bouton texte "Crop" -->
        <button id="crop-down"><i>&#x2193;</i></button> <!-- Fl√®che vers le bas -->
    </div>
    <div id="live-view">
        <img id="live-image" src="" alt="Image en direct" style="max-width: 100%; border: 1px solid #000;">
    </div>
    <h1>Valeurs ADU</h1>
    <div class="adu-container">
        <div id="adu-red" class="adu-box red">---</div>
        <div id="adu-green" class="adu-box green">---</div>
        <div id="adu-blue" class="adu-box blue">---</div>
    </div>
    <h2>Graphique d'Intensit√©</h2>
    <div class="chart-container">
        <canvas id="intensityChart"></canvas>
    </div>
    <h2>Graphique Spectrum</h2>
    <div class="chart-container">
        <canvas id="spectrumChart"></canvas>
    </div>
    <div id="response">
        <strong>R√©ponse du serveur :</strong>
        <pre id="response-text">...</pre>
    </div>
    
    <script>
        // Determine the hostname
        //const fallbackHostname = "10.42.0.1";
        const fallbackHostname = "192.168.1.30";
        const currentUrl = window.location.href;
        const hostname = currentUrl.startsWith("http")
            ? window.location.hostname // Use the hostname from the current URL
            : fallbackHostname; // Use the fallback hostname for local files
        
        const cameraStatusUrl = `http://${hostname}:8000/camera/status`;
        const connectUrl = `http://${hostname}:8000/camera/imx477/connect`;
        const disconnectUrl = `http://${hostname}:8000/camera/disconnect`;
        const cameraStatusElement = document.getElementById("camera-status");
        const controlsUrl = `http://${hostname}:8000/camera/controls/`;
        const normalizeUrl = (mode) => `http://${hostname}:8000/camera/toggle-normalize/${mode}`;
        const toggleMonobinModeUrl = `http://${hostname}:8000/camera/toggle-monobin-mode/`;
        const restartUrl = `http://${hostname}:8000/sunscan/reboot`;
        const shutdownUrl = `http://${hostname}:8000/sunscan/shutdown`;
        const infosUrl = `http://${hostname}:8000/sunscan/stats`;
        const takeSnapshotUrl = `http://${hostname}:8000/camera/take-snapshot/`;
        const startRecordUrl = `http://${hostname}:8000/camera/record/start/`;
        const stopRecordUrl = `http://${hostname}:8000/camera/record/stop/`;
        const cropUpUrl = `http://${hostname}:8000/camera/crop/up/`;
        const cropDownUrl = `http://${hostname}:8000/camera/crop/down/`;
        const toggleCropUrl = `http://${hostname}:8000/camera/toggle-crop/`;


        const ctx = document.getElementById("intensityChart").getContext("2d");

        const websocketUrl = `ws://${hostname}:8000/ws`;
        let socket;

        async function sendRequest(url, buttonLabel) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Erreur HTTP ${response.status}`);
                const data = await response.json();
                responseText.textContent = JSON.stringify(data, null, 2);
                console.log(`R√©ponse ${buttonLabel} :`, data);
                updateCropInfo(data);
            } catch (error) {
                console.error(`Erreur lors de l'action ${buttonLabel}:`, error);
                responseText.textContent = `Erreur : ${error.message}`;
                alert(`Erreur : Impossible d'effectuer ${buttonLabel}.`);
            }
        }
        
        // R√©f√©rencement de l'√©l√©ment image
        const liveImage = document.getElementById("live-image");
        const responseText = document.getElementById("response-text");
        const connectionInfoElement = document.getElementById("connection-hostname");
        const normalizeButtons = document.querySelectorAll(".normalize-button");
        const colorIndicator = document.getElementById("color-indicator");
        const websocketStatusElement = document.getElementById("websocket-status");

        // Display the hostname/IP in the UI
        connectionInfoElement.textContent = hostname;
        // Cr√©er un graphique d'intensit√©
        const intensityChart = new Chart(ctx, {
        type: "line",
        data: {
            labels: [], // Les indices des donn√©es (seront remplis dynamiquement)
            datasets: [{
                label: "Intensit√©",
                data: [], // Les valeurs d'intensit√©
                borderColor: "rgba(75, 192, 192, 1)",
                backgroundColor: "rgba(75, 192, 192, 0.2)",
                borderWidth: 1,
                pointRadius: 0, // Pas de points sur la courbe pour un graphique fluide
                fill: true, // Zone sous la courbe remplie
            }],
        },
        options: {
            responsive: true,
            plugins: {
                legend: {
                    display: true,
                    position: "top",
                },
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: "√âchantillons",
                    },
                },
                y: {
                    title: {
                        display: true,
                        text: "Valeurs d'intensit√©",
                    },
                },
            },
        },
    });
        const ctxSpectrum = document.getElementById("spectrumChart").getContext("2d");
        const spectrumChart = new Chart(ctxSpectrum, {
            type: "line",
            data: {
                labels: [],
                datasets: [{
                    label: "Spectrum",
                    data: [],
                    borderColor: "rgba(255, 99, 132, 1)",
                    backgroundColor: "rgba(255, 99, 132, 0.2)",
                    borderWidth: 1,
                    pointRadius: 0,
                    fill: true,
                }],
            },
            options: {
                responsive: true,
                scales: {
                    x: { title: { display: true, text: "√âchantillons" } },
                    y: { title: { display: true, text: "Valeurs spectrales" } }
                },
            },
        });
        // Mise √† jour du statut de la cam√©ra
        async function updateStatus() {
            try {
                const response = await fetch(cameraStatusUrl);
                if (response.ok) {
                    const data = await response.json();
                    cameraStatusElement.textContent = data.camera_status;
                    // Update the color indicator based on server state
                    if (data.monobin_mode !== undefined) {
                        updateColorIndicator(data.monobin_mode);
                    }
                } else {
                    console.error("Erreur lors de la r√©cup√©ration du statut.");
                    cameraStatusElement.textContent = "Erreur";
                }
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                cameraStatusElement.textContent = "Erreur r√©seau";
            }
        }

         // Connecter la cam√©ra
         async function connectCamera() {
            try {
                const response = await fetch(connectUrl);
                if (response.ok) {
                    const data = await response.json();
                    cameraStatusElement.textContent = data.camera_status;
                    if (data.camera_status === "connected") {
                        startWebSocket();
                    }
                } else {
                    console.error("Erreur lors de la connexion.");
                }
            } catch (error) {
                console.error("Erreur r√©seau :", error);
            }
        }

        // D√©connecter la cam√©ra
        async function disconnectCamera() {
            try {
                const response = await fetch(disconnectUrl);
                if (response.ok) {
                    const data = await response.json();
                    cameraStatusElement.textContent = data.camera_status;
                    if (data.camera_status === "disconnected") {
                        stopWebSocket();
                    }
                } else {
                    console.error("Erreur lors de la d√©connexion.");
                }
            } catch (error) {
                console.error("Erreur r√©seau :", error);
            }
        }

        function updateLiveImage_blob(base64Image, liveImage) {
            try {
                // Convertir Base64 en Blob
                const byteString = atob(base64Image.split(",")[1]);
                const mimeString = base64Image.split(",")[0].split(":")[1].split(";")[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                const blob = new Blob([ab], { type: mimeString });

                // Cr√©er une URL pour le Blob
                const objectURL = URL.createObjectURL(blob);

                // Lib√©rer l'ancienne URL pour √©viter les fuites m√©moire
                if (liveImage.src.startsWith("blob:")) {
                    URL.revokeObjectURL(liveImage.src);
                }

                // Charger la nouvelle image
                liveImage.src = objectURL;
            } catch (error) {
                console.error("Erreur lors de la mise √† jour de l'image live :", error);
            }
        }

        function updateLiveImage_base64(base64Image, liveImage) {
            try {
                // V√©rifie si l'image est diff√©rente de l'actuelle
                if (liveImage.dataset.lastSrc !== base64Image) {
                    liveImage.src = base64Image;
                    liveImage.dataset.lastSrc = base64Image; // Stocke la derni√®re image dans un attribut personnalis√©
                }
            } catch (error) {
                console.error("Erreur lors de la mise √† jour de l'image live :", error);
            }
        }

        // G√©rer WebSocket
        function startWebSocket() {
            if (socket) {
                socket.close(); // Close existing WebSocket if open
            }
            socket = new WebSocket(websocketUrl);
            // Update the WebSocket status
            websocketStatusElement.textContent = "Connexion en cours...";

            socket.addEventListener("open", () => {
                websocketStatusElement.textContent = "Connect√©";
                console.log("Connexion WebSocket √©tablie.");
            });

            socket.addEventListener("message", (event) => {
                try {
                    const message = event.data; // Message brut
                    if (message.startsWith("camera;#;")) {
                        const parts = message.split(";#;");
                        if (parts.length >= 4) {
                            const base64Image = parts[3];
                            //liveImage.src = ""; // Lib√®re l'ancienne image avant d'en charger une nouvelle
                            liveImage.src = base64Image;
                            //updateLiveImage_base64(base64Image, liveImage);
                        }
                    }
                    else if (message.startsWith("intensity;#;")) {
                        const dataString = message.split(";#;")[1]; // Obtenir les valeurs apr√®s "intensity;#;"
                        const intensityValues = dataString.split(",").map(Number); // Convertir en tableau de nombres

                        // Mettre √† jour les donn√©es du graphique
                        intensityChart.data.labels = intensityValues.map((_, index) => index); // Cr√©er des indices [0, 1, 2, ...]
                        intensityChart.data.datasets[0].data = intensityValues;

                        // Rafra√Æchir le graphique
                        intensityChart.update();
                    }
                    else if (message.startsWith("spectrum;#;")) {
                        const dataString = message.split(";#;")[1];
                        const spectrumValues = dataString.split(",").map(Number);

                        spectrumChart.data.labels = spectrumValues.map((_, index) => index);
                        spectrumChart.data.datasets[0].data = spectrumValues;
                        spectrumChart.update();
                    }
                    else if (message.startsWith("adu;#;")) {
                        const parts = message.split(";#;");
                        if (parts.length === 4) { // V√©rifie qu'il y a bien trois valeurs apr√®s le pr√©fixe
                            // Mettre √† jour les valeurs ADU
                            document.getElementById("adu-red").textContent = parts[1];
                            document.getElementById("adu-green").textContent = parts[2];
                            document.getElementById("adu-blue").textContent = parts[3];
                        }
                    }
                }
                catch (error) {
                    console.error("Erreur lors du traitement du message:", error);
                }
            });

            socket.addEventListener("error", (error) => {
                websocketStatusElement.textContent = "Erreur";
                console.error("Erreur WebSocket:", error);
            });

            socket.addEventListener("close", () => {
                websocketStatusElement.textContent = "D√©connect√©";
                console.log("Connexion WebSocket ferm√©e.");
            });
        }
        function stopWebSocket() {
            if (socket) {
                socket.close();
                socket = null;
            }
        }

        // Fonction pour appliquer les contr√¥les
        async function applyControls() {
            const exposureValue = parseFloat(document.getElementById("exposure").value);
            const gainValue = parseFloat(document.getElementById("gain").value);
            const maxVisuThreshold = 256;

            if (
                isNaN(exposureValue) || exposureValue < 0.1 || exposureValue > 10000.0 ||
                isNaN(gainValue) || gainValue < 1.0 || gainValue > 10.0
            ) {
                alert("Les valeurs saisies ne sont pas valides.");
                return;
            }

            const payload = {
                exp: exposureValue,
                gain: gainValue,
                max_visu_threshold: maxVisuThreshold
            };

            try {
                const response = await fetch(controlsUrl, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible d'appliquer les contr√¥les.";
            }
        }

         // Function to update normalization mode
         async function updateNormalization(mode) {
            try {
                const response = await fetch(normalizeUrl(mode), {
                    method: "GET",
                });

                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);

                // Update button states
                normalizeButtons.forEach((button) => {
                    if (button.dataset.normalization === mode.toString()) {
                        button.classList.add("active");
                    } else {
                        button.classList.remove("active");
                    }
                });
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible de changer le mode de normalisation.";
            }
        }
        
        // Function to toggle color mode
        async function toggleColorMode() {
            try {
                const response = await fetch(toggleMonobinModeUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);

                // Update the color indicator
                updateColorIndicator(responseData.monobin_mode);
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible de changer le canal de couleur.";
            }
        }

        // Update the color indicator based on the mode
        function updateColorIndicator(mode) {
            colorIndicator.className = "color-indicator"; // Reset classes
            switch (mode) {
                case 0:
                    colorIndicator.classList.add("color-rgb");
                    break;
                case 1:
                    colorIndicator.classList.add("color-red");
                    break;
                case 2:
                    colorIndicator.classList.add("color-green");
                    break;
                case 3:
                    colorIndicator.classList.add("color-blue");
                    break;
                default:
                    console.error("Mode inconnu :", mode);
            }
        }

        // Function to restart the Raspberry Pi
        async function restartRpi() {
            if (!confirm("√ätes-vous s√ªr de vouloir red√©marrer le Raspberry Pi ? Cette action ne peut pas √™tre annul√©e.")) {
                return; // Abort if the user cancels
            }

            try {
                const response = await fetch(restartUrl, { method: "POST" });
                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);
                alert("Le Raspberry Pi est en cours de red√©marrage.");
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible de red√©marrer le Raspberry Pi.";
            }
        }

        // Function to shut down the Raspberry Pi
        async function shutdownRpi() {
            if (!confirm("√ätes-vous s√ªr de vouloir √©teindre le Raspberry Pi ? Cette action ne peut pas √™tre annul√©e.")) {
                return; // Abort if the user cancels
            }

            try {
                const response = await fetch(shutdownUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);
                alert("Le Raspberry Pi est en train de s'√©teindre.");
                actionStatusElement.textContent = "Shutdown en cours...";
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible d'√©teindre le Raspberry Pi.";
                actionStatusElement.textContent = "Erreur lors du shutdown.";
            }
        }

        // Function to take a snapshot
        async function takeSnapshot() {
            try {
                const response = await fetch(takeSnapshotUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);
                alert("Snapshot captur√© avec succ√®s !");
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible de capturer le snapshot.";
            }
        }
        
        // Function to start recording
        async function startRecording() {
            try {
                const response = await fetch(startRecordUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);
                // Check the record state in the response
                if (responseData.record === true) {
                    alert("Enregistrement d√©marr√© !");
                } else {
                    alert("Enregistrement d√©j√† en cours ou non d√©marr√© correctement.");
                }
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible de d√©marrer l'enregistrement.";
            }
        }

        // Function to stop recording
        async function stopRecording() {
            try {
                const response = await fetch(stopRecordUrl);
                if (!response.ok) {
                    throw new Error(`Erreur HTTP : ${response.status}`);
                }

                const responseData = await response.json();
                responseText.textContent = JSON.stringify(responseData, null, 2);
                // Check the record state in the response
                if (responseData.record === false) {
                    alert("Enregistrement arr√™t√© !");
                } else {
                    alert("Aucun enregistrement en cours √† arr√™ter ou probl√®me rencontr√©.");
                }
            } catch (error) {
                console.error("Erreur r√©seau :", error);
                responseText.textContent = "Erreur : Impossible d'arr√™ter l'enregistrement.";
            }
        }
        
        // Fonction pour mettre √† jour les informations de Crop
        function updateCropInfo(data) {
            const cropInfo = document.getElementById("crop-info");
            const crop_y = data.crop_y || "---";
            const crop_height = data.crop_height || "---";
            cropInfo.innerHTML = `
                <span>Crop Y: ${crop_y}</span>
                <span>Crop Height: ${crop_height}</span>
            `;
        }

        document.getElementById("connect-button").addEventListener("click", connectCamera);
        document.getElementById("disconnect-button").addEventListener("click", disconnectCamera);
        document.getElementById("update-status").addEventListener("click", updateStatus);
        document.getElementById("apply-controls").addEventListener("click", applyControls);
        document.getElementById("toggle-color-mode").addEventListener("click", toggleColorMode);
        // Attach click events to normalization buttons
        normalizeButtons.forEach((button) => {
            button.addEventListener("click", () => {
                const mode = button.dataset.normalization;
                updateNormalization(mode);
            });
        });
        document.getElementById("restart-rpi").addEventListener("click", restartRpi);
        document.getElementById("shutdown-rpi").addEventListener("click", shutdownRpi);
        document.getElementById("sunscan-infos").addEventListener("click", () => sendRequest(infosUrl, "Sunscan Infos"));
        document.getElementById("take-snapshot").addEventListener("click", takeSnapshot);
        document.getElementById("start-record").addEventListener("click", startRecording);
        document.getElementById("stop-record").addEventListener("click", stopRecording);
        // Attach event to recreate WebSocket
        document.getElementById("recreate-websocket").addEventListener("click", () => {
            startWebSocket();
        });
        // Attachement des √©v√©nements pour les boutons
        document.getElementById("crop-up").addEventListener("click", () => sendRequest(cropUpUrl, "Crop Up"));
        document.getElementById("crop-down").addEventListener("click", () => sendRequest(cropDownUrl, "Crop Down"));
        document.getElementById("toggle-crop").addEventListener("click", () => sendRequest(toggleCropUrl, "Toggle Crop"));

        // V√©rifier le statut au chargement de la page
        updateStatus();
    </script>
</body>
</html>
